# Capter

* golang сервер (capter)
* торчащий shared key-value (capterka)

## Легенда

При освоении планет и терраформинге появилась необходимость засылать определенные химические элементы, образцы почвы, примеры ландшафта на различные участки планеты, чтобы смотреть, что и где приживется. Для чистоты эксперимента, рассылающий модуль выбирает несколько мест случайным образом, отправляет туда образцы, и впоследствии проверяет, удачный ли был выбор.
Если образцы успешно прижились, эксперимент продолжается пока планета не будет признана полностью готовой к жизни, в противном случае, место на некоторое время исключается из списка пригодных. Чем больше экспериментов прижилось, тем более приоритетным будет место для жизни в будущем.

Такой системой оказался  C.A.P.T.E.R - Cosmic Automatic Pattern Transmitter-Exchanger-Receiver

## Описание файлов

### C.A.P.T.E.R

Сервис

+ Cosmic - утилиты
+ Automatic - основная логика C.A.P.T.E.R
+ Pattern - создание образцов
+ Transmitter - рассылка образцов
+ Excahger - приложение
+ Receiver - получение образцов


### C.A.P.T.E.R.Сa

БД

C.A.P.T.E.R.Сa - C.A.P.T.E.R Candidate

Место-кандидат для отправки образцов.

Задепоить только бинарник - там ничего интересного.


## Build for Docker

    GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build

## Уязвимости

### LIST

>Простая уязвимость.
> Требует смекалки и знания REST (в частности http OPTIONS), либо реверса Go - так или иначе, поняв, как работает LIST можно таскать флаги пачками. Для защиты требуется запатчить бинарник или, что проще, спрятать Capterca за реверс-прокси и запретить все, кроме GET,POST,LEN (LEN нужно чекеру)

Capterca помимо GET и POST имеет также методы LEN, LIST и OPTIONS.
OPTIONS собственно рассказывает какие методы есть. 
LEN говорит количество записей в базе
LIST - принимает параметр $key, и выводит список всех ключей в базе, начинающихся с $key.

Таким образом, зная, что ключи в базе строятся по принципу timestamp-id, можно выбрать все ключи, начинающиеся с таймстемпа раунда, после чего пройтись по командам и сделать get для данных id.


## Мысли (по мере выполнения перейдет в описание)

1. Store:
    1. Каптер шифрует флаг и сохраняет на произвольные 4 команды (взвешенные по локальному sla)
    2. Каптер сохраняет локально в bolt: id -> team1:team2:team3:team4:password
2. Get:
    1. Каптер берет адрес флага из локального bolt
    2. Забирает флаг с команд из Каптерки
       Если ответы разные - в приоритете такой флаг, который встретился на большем числе команд.
    3. Ответившим командам увеличивает SLA на 1
    3. Расшифровывает и показывает

База без авторизации доступна всем appendonly, но кроме id из нее ничего получить нельзя, так как данные шифрованы.
Шифрование TEA с 5 раундами. Часть текста известна (это id флага) (почти 40%)
Но так как ключ для каждого флага свой - решается TEA только полным перебором, что требует больше времени, чем идут соревнования.

Хочу еще уязвимость((((