# Capter

* golang сервер (capter)
* торчащий shared key-value (capterka)

## Легенда

При освоении планет и терраформинге появилась необходимость засылать определенные химические элементы, образцы почвы, примеры ландшафта на различные участки планеты, чтобы смотреть, что и где приживется. Для чистоты эксперимента, рассылающий модуль выбирает несколько мест случайным образом, отправляет туда образцы, и впоследствии проверяет, удачный ли был выбор.
Если образцы успешно прижились, эксперимент продолжается пока планета не будет признана полностью готовой к жизни, в противном случае, место на некоторое время исключается из списка пригодных. Чем больше экспериментов прижилось, тем более приоритетным будет место для жизни в будущем.

Такой системой оказался  C.A.P.T.E.R - Cosmic Automatic Pattern Transmitter-Exchanger-Receiver

## Описание файлов

### C.A.P.T.E.R

Сервис

+ Cosmic - утилиты
+ Automatic - основная логика C.A.P.T.E.R
+ Pattern - создание образцов
+ Transmitter - рассылка образцов
+ Excahger - приложение
+ Receiver - получение образцов


### C.A.P.T.E.R.Сa

БД

C.A.P.T.E.R.Сa - C.A.P.T.E.R Candidate

Место-кандидат для отправки образцов.

Задепоить только бинарник - там ничего интересного.


## Build for Docker

    GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build

## Уязвимости

### LIST

>Простая уязвимость.
> Требует смекалки и знания REST (в частности http OPTIONS), либо реверса Go - так или иначе, поняв, как работает LIST можно таскать флаги пачками. Для защиты требуется запатчить бинарник или, что проще, спрятать Capterca за реверс-прокси и запретить все, кроме GET,POST,LEN (LEN нужно чекеру)

Capterca помимо GET и POST имеет также методы LEN, LIST и OPTIONS.
OPTIONS собственно рассказывает какие методы есть. 
LEN говорит количество записей в базе
LIST - принимает параметр $key, и выводит список всех ключей в базе, начинающихся с $key.

Таким образом, зная, что ключи в базе строятся по принципу timestamp-id, можно выбрать все ключи, начинающиеся с таймстемпа раунда, после чего пройтись по командам и сделать get для данных id.

Даже если бы LIST не было - всё равно есть возможность выводить все ключи для своей базы, после чего запрашивать у сервиса флаги по id.

Таким образом, чтобы закрыться от этой архитектурной уязвимости - стоит на сервисе сохранять в Capterca не с тем же id, а с неким внутренним, имея соответствие в локальной базе сервиса. Таким образом, даже зная все ключи из Capterca не будет возможности получить флаг - только зашифрованное значение.

### Crypto

>Криптография избыточна

Для шифрования используется пароль из 16 символов, но на деле из-за за сдвигов используется меньше. Более того, при внимательном рассмотрении оказывается, что вместо 16 символьного пароля, для расшифровки нужны лишь два uint32 числа.
Более того, эти числа можно легко вычислить, зная открытую часть. (см. sploits/capter/crypto/sploit.go)

Необходимо усилить криптографию, например увеличив количество раундов на блок, либо поменяв алгоритм, заменив XOR на что-то иное(хотя б на сложение)

## Мысли (по мере выполнения перейдет в описание)

1. Store:
    1. Каптер шифрует флаг и сохраняет на произвольные 4 команды (взвешенные по локальному sla)
    2. Каптер сохраняет локально в bolt: id -> team1:team2:team3:team4:password
2. Get:
    1. Каптер берет адрес флага из локального bolt
    2. Забирает флаг с команд из Каптерки
       Если ответы разные - в приоритете такой флаг, который встретился на большем числе команд.
    3. Ответившим командам увеличивает SLA на 1
    3. Расшифровывает и показывает

База без авторизации доступна всем appendonly, но кроме id из нее ничего получить нельзя, так как данные шифрованы.
Шифрование TEA с 5 раундами. Часть текста известна (это id флага) (почти 40%)
Но так как ключ для каждого флага свой - решается TEA только полным перебором, что требует больше времени, чем идут соревнования.